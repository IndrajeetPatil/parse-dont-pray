---
format:
  revealjs:
    title-slide-attributes:
      data-visibility: hidden
    css: style.css
    theme: simple
    slide-number: true
    code-line-numbers: false
    preview-links: auto
    keyboard: true
    touch: true
    help: true
    include-in-header: meta-tags.html
    link-external-newwindow: true
    mermaid-format: png
revealjs-plugins:
  - fontawesome
execute:
  echo: true
  eval: false
keywords: ["data-validation", "pydantic", "zod", "python", "typescript", "software-engineering", "type-safety"]
description-meta: "Explore the benefits of data validation libraries like Pydantic and Zod. Learn how they improve readability, type safety, testing, security, and maintainability in your applications."
license: "CC0 1.0 Universal"
pagetitle: "Parse, Don't Pray: The Case for Data Validation"
author-meta: "Indrajeet Patil"
date-meta: "2025-12-06"
lang: "en"
dir: "ltr"
image: "media/social-media-card.jpg"
image-alt: "Parse, Don't Pray - Two hands clasped together symbolizing the partnership between Pydantic and Zod for data validation"
canonical-url: "https://indrajeetpatil.github.io/parse-dont-pray/"
---

## {.unnumbered .unlisted}

::: {style="text-align: center;"}

::: {style="font-size: 1.3em; font-weight: bold; margin-bottom: 0.4em;"}
Parse, Don't Pray: The Case for Data Validation
:::

::: {style="font-size: 0.9em; margin-bottom: 0.1em;"}
Indrajeet Patil
:::

::: {style="display: flex; justify-content: center; margin-top: 0.2em;"}
![](media/social-media-card.jpg){width="85%" style="max-height: 400px; object-fit: contain;" fig-alt="Parse, Don't Pray - Two hands clasped together symbolizing the partnership between Pydantic and Zod for data validation"}
:::

:::

::: {.footer style="text-align: center; font-size: 0.55em; color: #999; position: absolute; bottom: 20px; left: 0; right: 0;"}
Source code: [github.com/IndrajeetPatil/parse-dont-pray](https://github.com/IndrajeetPatil/parse-dont-pray/)
:::

## What You'll Learn {.smaller}

- Why data validation libraries are essential for robust applications
- Why validation is needed on **both** client and server (not just one)
- How Pydantic (Python) and Zod (TypeScript) improve code quality
- Benefits across readability, runtime behavior, typing, testing, and security

::: {style="background-color: #FFFBC1; padding: 20px; border-radius: 25px; text-align: center;"}

üéØ **Goal**

Create a **validated type system** that works at runtime, ensuring data actually matches your assumptions.

:::

<br>

::: {style="background-color: #e3f2fd; padding: 20px; border-radius: 25px; text-align: center;"}

Examples assume a **Python-TypeScript** full-stack, but the principles apply to other stacks.

::: {style="font-size: 0.7em; margin-top: 8px;"}
Python examples use `from pydantic import *` for brevity; prefer explicit imports in production.
:::

:::

# Introduction

*Why data validation matters*

## Dynamic vs Static Typing {.smaller}

Type systems differ in **when** they catch type errors.

:::: {.columns}

::: {.column width="50%" .fragment}

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; font-size: 0.85em;"}

::: {style="font-size: 1.05em; font-weight: bold; margin-bottom: 8px;"}
**Statically Typed** (e.g., Java, C++, Rust)
:::

- Types checked at **compile time**
- Type errors caught before runtime
- More verbose type declarations
- Compiler guarantees type safety

::: {style="font-size: 1.1em;"}
```rust
fn greet(name: String) -> String {
    format!("Hello, {}!", name)
}

// Won't compile: type mismatch
greet(42);  // Error at compile time
```
:::

:::

:::

::: {.column width="50%" .fragment}

::: {style="background-color: #fff3e0; padding: 15px; border-radius: 10px; font-size: 0.85em;"}

::: {style="font-size: 1.05em; font-weight: bold; margin-bottom: 8px;"}
**Dynamically Typed** (e.g., Python, JavaScript)
:::

- Types checked at **runtime**
- Type errors appear during execution
- More flexible, less verbose
- No compile-time type guarantees

::: {style="font-size: 1.1em;"}
```python
def greet(name: str) -> str:
    return f"Hello, {name.upper()}!"

# Works with correct type
greet("alice")  # "Hello, ALICE!"
# Wrong type fails at runtime
greet(42)       # Runtime error: 'int' object has no attribute 'upper'
```
:::

:::

:::

::::

. . .

::: {style="background-color: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 20px; text-align: center; font-size: 0.9em;"}

**Why validation matters more for dynamic languages**: <br>
Without compile-time checks, **runtime validation** ensures data integrity.

:::

## What is Data Validation? {.smaller}

Ensuring data meets specific criteria before use.

:::: {.columns}

::: {.column width="50%" .fragment}

::: {style="background-color: #ffebee; padding: 15px; border-radius: 10px; font-size: 0.85em;"}

::: {style="font-size: 1.05em; font-weight: bold; margin-bottom: 8px;"}
**‚ùå Without validation libraries**
:::

Manual checks scattered throughout code:

- Type, range, and format checks written by hand
- Logic spreads across codebase
- Difficult to maintain and extend

:::

:::

::: {.column width="50%" .fragment}

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; font-size: 0.85em;"}

::: {style="font-size: 1.05em; font-weight: bold; margin-bottom: 8px;"}
**‚úÖ With validation libraries**
:::

Schemas automatically validate, parse, and type data:

- Centralized, self-documenting rules
- Automatic type coercion
- Detailed error messages
- Easier to maintain and evolve

:::

:::

::::

## Meet the Libraries {.smaller}

:::: {.columns}

::: {.column width="50%" .fragment}

::: {style="background-color: #ffffff; border: 2px solid #E92063; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-size: 0.85em; text-align: center;"}

::: {style="height: 100px; display: flex; align-items: center; justify-content: center; margin-bottom: 15px;"}
![](media/pydantic-logo.png){width="100px" fig-alt="Pydantic logo"}
:::

::: {style="font-size: 1.05em; font-weight: bold; margin-bottom: 10px;"}
**Pydantic** (Python)
:::

Runtime data validation using Python type annotations

::: {style="margin-top: 10px; font-size: 0.95em;"}
[docs.pydantic.dev](https://docs.pydantic.dev/latest/)
:::

:::

:::

::: {.column width="50%" .fragment}

::: {style="background-color: #ffffff; border: 2px solid #3E67B1; border-radius: 15px; padding: 20px; box-shadow: 0 4px 6px rgba(0,0,0,0.1); font-size: 0.85em; text-align: center;"}

::: {style="height: 100px; display: flex; align-items: center; justify-content: center; margin-bottom: 15px;"}
![](media/zod-logo.webp){width="100px" fig-alt="Zod logo"}
:::

::: {style="font-size: 1.05em; font-weight: bold; margin-bottom: 10px;"}
**Zod** (TypeScript)
:::

TypeScript-first schema validation with type inference

::: {style="margin-top: 10px; font-size: 0.95em;"}
[zod.dev](https://zod.dev/)
:::

:::

:::

::::

# Benefits of Data Validation Libraries

*Creating robust, maintainable applications*

# Readability

*Self-documenting schemas that reduce cognitive load*

## Self-Documenting Schemas {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

```python
from pydantic import *
from typing import Annotated, Literal

UserName = Annotated[str, Field(min_length=3, max_length=20)]

class UserProfile(BaseModel):
    username: UserName
    email: EmailStr
    age: int = Field(ge=18, le=120)
    role: Literal["admin", "user", "guest"]
    is_active: bool = True
```

### TypeScript (Zod)

```typescript
import { z } from "zod";

const UserName = z.string().min(3).max(20);

const UserProfileSchema = z.object({
  username: UserName,
  email: z.string().email(),
  age: z.number().int().min(18).max(120),
  role: z.enum(["admin", "user", "guest"]),
  isActive: z.boolean().default(true),
});

type UserProfile = z.infer<typeof UserProfileSchema>;
```

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
The schema **is** the documentation ‚Äì no separate docs needed!
:::

::: {style="background-color: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 10px; text-align: center;"}
Schema definition, validation logic, and type information live in **one place** ‚Äì a single source of truth.
:::

## Declarative Syntax {.smaller}

::: {.panel-tabset}

### Python

:::: {.columns}

::: {.column width="50%"}

**Without Pydantic**

::: {style="background-color: #ffebee; padding: 15px; border-radius: 8px;"}

```python
# Imperative: Lots of manual checks
def validate_user(data):
    if not isinstance(data.get('email'), str):
        raise ValueError('Email must be string')
    if '@' not in data['email']:
        raise ValueError('Invalid email')
    if not isinstance(data.get('age'), int):
        raise ValueError('Age must be integer')
    if data['age'] < 18 or data['age'] > 120:
        raise ValueError('Age must be 18-120')
    # ... and so on
```

:::

:::

::: {.column width="50%"}

**With Pydantic**

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 8px;"}

```python
from pydantic import *

class User(BaseModel):
    email: EmailStr
    age: int = Field(ge=18, le=120)
```

:::

:::

::::

### TypeScript

:::: {.columns}

::: {.column width="50%"}

**Without Zod**

::: {style="background-color: #ffebee; padding: 15px; border-radius: 8px;"}

```typescript
// Imperative: Lots of manual checks
function validateUser(data: any) {
  if (typeof data.email !== 'string') {
    throw new Error('Email must be string');
  }
  if (!data.email.includes('@')) {
    throw new Error('Invalid email');
  }
  if (typeof data.age !== 'number') {
    throw new Error('Age must be number');
  }
  if (data.age < 18 || data.age > 120) {
    throw new Error('Age must be 18-120');
  }
  // ... and so on
}
```

:::

:::

::: {.column width="50%"}

**With Zod**

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 8px;"}

```typescript
import { z } from "zod";

const UserSchema = z.object({
  email: z.string().email(),
  age: z.number().int().min(18).max(120),
});

type User = z.infer<typeof UserSchema>;
```

:::

:::

::::

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Describes *what* the data should look like, not *how* to validate it.
:::

## Specific Types Over Generic {.smaller}

::: {style="font-size: 0.85em;"}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="24%"}

::: {style="background-color: #ffebee; padding: 12px; border-radius: 8px; font-size: 0.9em;"}

**‚ùå Generic: `str`**

```python
class User(BaseModel):
    email: str
```

- Accepts any string
- No validation
- Unclear intent

:::

:::

::: {.column width="38%"}

::: {style="background-color: #fff3e0; padding: 12px; border-radius: 8px; font-size: 0.9em;"}

**‚ö†Ô∏è Better: `EmailStr`**

```python
class User(BaseModel):
    email: EmailStr
```

- Validates email format
- Self-documenting
- Still generic

:::

:::

::: {.column width="38%"}

::: {style="background-color: #e8f5e9; padding: 12px; border-radius: 8px; font-size: 0.9em;"}

**‚úÖ Best: `AcmeEmailStr`**

```python
from pydantic import *
from typing import Annotated

def must_be_acme(value: str) -> str:
    if not value.endswith('@acme.com'):
        raise ValueError('Must be @acme.com')
    return value

AcmeEmailStr = Annotated[
    EmailStr,
    AfterValidator(must_be_acme),
]

class User(BaseModel):
    email: AcmeEmailStr
```

- Domain-specific
- Business rule enforced
- Crystal clear intent

:::

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="24%"}

::: {style="background-color: #ffebee; padding: 12px; border-radius: 8px; font-size: 0.9em;"}

**‚ùå Generic: `string`**

```typescript
const UserSchema = z.object({
  email: z.string(),
});
```

- Accepts any string
- No validation
- Unclear intent

:::

:::

::: {.column width="38%"}

::: {style="background-color: #fff3e0; padding: 12px; border-radius: 8px; font-size: 0.9em;"}

**‚ö†Ô∏è Better: `.email()`**

```typescript
const UserSchema = z.object({
  email: z.string().email(),
});
```

- Validates email format
- Self-documenting
- Still generic

:::

:::

::: {.column width="38%"}

::: {style="background-color: #e8f5e9; padding: 12px; border-radius: 8px; font-size: 0.9em;"}

**‚úÖ Best: Custom refinement**

```typescript
const acmeEmail = z
  .string()
  .email()
  .refine(
    (email) => email.endsWith('@acme.com'),
    { message: 'Must be @acme.com email' }
  );

const UserSchema = z.object({
  email: acmeEmail,
});
```

- Domain-specific
- Business rule enforced
- Crystal clear intent

:::

:::

::::

:::

::: {style="background-color: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
`str` ‚Üí `EmailStr` ‚Üí `AcmeEmailStr` = Increasing specificity = Better readability
:::

:::

# Runtime Behavior

*Catch errors early before they propagate*

## Automatic Validation {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *

class ProductPrice(BaseModel):
    product_id: str
    price: PositiveFloat
    currency: str = Field(pattern=r'^[A-Z]{3}$')
```

:::

::: {.column width="50%"}

**Validation Examples**

```python
# ‚úÖ Valid data passes through
ProductPrice(
    product_id="PROD-123",
    price=29.99,
    currency="USD"
)

# üö´ Invalid data blocked
ProductPrice(
    product_id="PROD-123",
    price=-10,     # Negative!
    currency="US"  # Invalid format!
)
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const ProductPriceSchema = z.object({
  productId: z.string(),
  price: z.number().positive(),
  currency: z.string().regex(/^[A-Z]{3}$/),
});
```

:::

::: {.column width="50%"}

**Validation Examples**

```typescript
// ‚úÖ Valid data passes through
ProductPriceSchema.parse({
  productId: "PROD-123",
  price: 29.99,
  currency: "USD",
});

// üö´ Invalid data blocked
ProductPriceSchema.parse({
  productId: "PROD-123",
  price: -10,     // Negative!
  currency: "US", // Invalid format!
});
```

:::

::::

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Data validated as it enters the system, catching errors early.
:::

## Data Coercion & Parsing {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *
from datetime import datetime

class Event(BaseModel):
    event_id: int        # Coerces string to int
    timestamp: datetime  # Parses ISO 8601 strings
    is_public: bool      # Coerces to bool
    attendees: list[str] # Coerces tuple to list
```

:::

::: {.column width="50%"}

**Coercion Examples**

```python
# String inputs are intelligently coerced
event = Event(
    event_id="42",                    # ‚Üí int 42
    timestamp="2024-01-15T10:30:00",  # ‚Üí datetime
    is_public="yes",                  # ‚Üí True
    attendees=("Alice", "Bob")        # ‚Üí list
)

print(event.event_id)   # 42 (int)
print(event.timestamp)  # datetime object
print(event.is_public)  # True (bool)
print(event.attendees)  # ["Alice", "Bob"]
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const EventSchema = z.object({
  eventId: z.coerce.number(),   // Coerce to number
  timestamp: z.coerce.date(),   // Parse to Date
  isPublic: z.boolean(),
  attendees: z.array(z.string()),
});
```

:::

::: {.column width="50%"}

**Coercion Examples**

```typescript
// String inputs are intelligently coerced
const event = EventSchema.parse({
  eventId: "42",                     // ‚Üí number 42
  timestamp: "2024-01-15T10:30:00",  // ‚Üí Date
  isPublic: true,
  attendees: ["Alice", "Bob"],
});

console.log(event.eventId);    // 42 (number)
console.log(event.timestamp);  // Date object
console.log(event.isPublic);   // true (boolean)
console.log(event.attendees);  // ["Alice", "Bob"]
```

:::

::::

:::

::: {style="background-color: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Handles common API/JSON data format conversions automatically!
:::

## Detailed Error Messages {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *

class SignupForm(BaseModel):
    username: str = Field(min_length=3)
    email: EmailStr
```

:::

::: {.column width="50%"}

**Error Messages**

```python
try:
    user = SignupForm(
        username="ab",        # Too short
        email="not-an-email", # Invalid format
    )
except ValidationError as e:
    print(e.json(indent=2))
    # Output:
    # [{
    #   "loc": ["username"],
    #   "msg": "at least 3 characters",
    #  },
    #  {
    #   "loc": ["email"],
    #   "msg": "not a valid email",
    # }]
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const SignupFormSchema = z.object({
  username: z.string().min(3),
  email: z.string().email(),
});
```

:::

::: {.column width="50%"}

**Error Messages**

```typescript
const result = SignupFormSchema.safeParse({
  username: "ab",            // Too short
  email: "not-an-email",     // Invalid format
});

if (!result.success) {
  console.log(result.error.format());
  // Output:
  // {
  //   "username": {
  //     "_errors": ["at least 3 character(s)"]
  //   },
  //   "email": { "_errors": ["Invalid email"] }
  // }
}
```

:::

::::

:::

::: {style="background-color: #fff3e0; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Specific, actionable feedback about what's wrong and where.
:::

# Typing

*Type inference that bridges static and runtime worlds*

## Type Inference {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *

class Address(BaseModel):
    street: str
    city: str
    zipcode: str
    country: str = "USA"

class Person(BaseModel):
    name: str
    age: int
    address: Address
    phone: str | None = None
```

:::

::: {.column width="50%"}

**Type Inference**

```python
# Type checkers understand types automatically
def get_person_city(person: Person) -> str:
    return person.address.city

# No separate type annotations needed
person = Person(
    name="Alice",
    age=30,
    address=Address(
        street="123 Main St",
        city="Boston",
        zipcode="02101"
    )
)

city: str = get_person_city(person)
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const AddressSchema = z.object({
  street: z.string(),
  city: z.string(),
  zipcode: z.string(),
  country: z.string().default("USA"),
});

const PersonSchema = z.object({
  name: z.string(),
  age: z.number(),
  address: AddressSchema,
  phone: z.string().optional(),
});
```

:::

::: {.column width="50%"}

**Type Inference**

```typescript
// Types automatically inferred from schema
type Person = z.infer<typeof PersonSchema>;

function getPersonCity(person: Person): string {
  return person.address.city;
}

const person = PersonSchema.parse({
  name: "Alice",
  age: 30,
  address: {
    street: "123 Main St",
    city: "Boston",
    zipcode: "02101"
  }
});

const city: string = getPersonCity(person);
```

:::

::::

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Schema is both validator and type definition!
:::

## End-to-End Type Safety {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *

class ApiResponse(BaseModel):
    status: str = Field(pattern=r'^(success|error)$')
    data: list[dict]
    message: str
```

:::

::: {.column width="50%"}

**Type-Safe Usage**

```python
def fetch_data_from_api() -> ApiResponse:
    raw_response = requests.get(
        "https://api.example.com/data"
    ).json()
    # Validates runtime data
    return ApiResponse(**raw_response)

def process_response(response: ApiResponse) -> None:
    # Type-safe throughout
    if response.status == "success":
        for item in response.data:
            process_item(item)

response = fetch_data_from_api()
process_response(response)
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const ApiResponseSchema = z.object({
  status: z.enum(["success", "error"]),
  data: z.array(z.record(z.unknown())),
  message: z.string(),
});

type ApiResponse = z.infer<typeof ApiResponseSchema>;
```

:::

::: {.column width="50%"}

**Type-Safe Usage**

```typescript
async function fetchDataFromApi(): Promise<ApiResponse> {
  const rawResponse = await fetch(
    "https://api.example.com/data"
  );
  const json = await rawResponse.json();
  // Validates runtime data
  return ApiResponseSchema.parse(json);
}

function processResponse(response: ApiResponse): void {
  // Type-safe throughout
  if (response.status === "success") {
    for (const item of response.data) {
      processItem(item);
    }
  }
}
```

:::

::::

:::

::: {style="background-color: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
External data is validated before entering your type-safe code!
:::

## Eliminates Type/Validation Drift {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Evolution**

```python
from pydantic import *
from typing import Literal

# Version 1: Original schema
class UserV1(BaseModel):
    name: str
    role: Literal["user", "admin"]

# Version 2: Updated schema
class UserV2(BaseModel):
    name: str
    role: Literal["user", "admin", "moderator"]
    email: str  # New required field
```

:::

::: {.column width="50%"}

**Type-Checked Usage**

```python
# Types automatically update
def process_user(user: UserV2) -> str:
    if user.role == "moderator":
        return f"Moderator {user.name}"
    elif user.role == "admin":
        return f"Admin {user.name}"
    else:
        return f"User {user.name}"

# Old code gets type errors
def old_process_user(user: UserV2) -> str:
    if user.role == "admin":
        return "admin"
  # With strict type-checker settings, missing cases are flagged.
    return "user"
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Evolution**

```typescript
import { z } from "zod";

// Version 1: Original schema
const UserV1Schema = z.object({
  name: z.string(),
  role: z.enum(["user", "admin"]),
});

// Version 2: Updated schema
const UserV2Schema = z.object({
  name: z.string(),
  role: z.enum(["user", "admin", "moderator"]),
  email: z.string(),  // New required field
});

type UserV2 = z.infer<typeof UserV2Schema>;
```

:::

::: {.column width="50%"}

**Type-Checked Usage**

```typescript
// Types automatically update
function processUser(user: UserV2): string {
  if (user.role === "moderator") {
    return `Moderator ${user.name}`;
  } else if (user.role === "admin") {
    return `Admin ${user.name}`;
  } else {
    return `User ${user.name}`;
  }
}

// Old code gets type errors
function oldProcessUser(user: UserV2): string {
  if (user.role === "admin") {
    return "admin";
  }
  const exhaustiveCheck: never = user.role;
  return exhaustiveCheck;
}
```

:::

::::

:::

::: {style="background-color: #fff3e0; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Update the schema once, then propagate via shared schemas or code generation.
:::

# Testing

*Reduce test burden with built-in validation*

## Reduced Test Burden {.smaller}

::: {.panel-tabset}

### Python

:::: {.columns}

::: {.column width="50%"}

**Without Pydantic**

::: {style="background-color: #ffebee; padding: 15px; border-radius: 8px;"}

```python
# Need tests for every validation rule
def test_signup_validation():
    with pytest.raises(ValueError):
        create_user(email="invalid")
    with pytest.raises(ValueError):
        create_user(age=17)
    with pytest.raises(ValueError):
        create_user(age=121)
    # ... more validation tests
```

:::

:::

::: {.column width="50%"}

**With Pydantic**

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 8px;"}

```python
from pydantic import *

class User(BaseModel):
    email: EmailStr
    age: int = Field(ge=18, le=120)

# Only test business logic, not validation
def test_user_permissions():
    admin = User(email="a@test.com", age=30)
    assert admin.has_permission("delete_users")

# Validation is covered by Pydantic itself.
```

:::

:::

::::

### TypeScript

:::: {.columns}

::: {.column width="50%"}

**Without Zod**

::: {style="background-color: #ffebee; padding: 15px; border-radius: 8px;"}

```typescript
// Need tests for every validation rule
describe("User validation", () => {
  it("rejects invalid email", () => {
    expect(() => createUser({ email: "invalid" }))
      .toThrow();
  });
  it("rejects young age", () => {
    expect(() => createUser({ age: 17 }))
      .toThrow();
  });
  // ... more validation tests
});
```

:::

:::

::: {.column width="50%"}

**With Zod**

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 8px;"}

```typescript
import { z } from "zod";

const UserSchema = z.object({
  email: z.string().email(),
  age: z.number().min(18).max(120),
});

type User = z.infer<typeof UserSchema>;

// Only test business logic, not validation
describe("User permissions", () => {
  it("admin has delete permission", () => {
    const admin = UserSchema.parse({
      email: "a@test.com", age: 30,
    });
    expect(admin.hasPermission("delete_users")).toBe(true);
  });
});

// Validation is covered by Zod itself.
```

:::

:::

::::

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Validation testing is delegated to the well-tested library!
:::

## Easy Mock Data Generation {.smaller}

::: {.panel-tabset}

### Python (Pydantic + Hypothesis)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *
from hypothesis.strategies import builds
from pydantic_factories import ModelFactory

class Product(BaseModel):
    product_id: str = Field(pattern=r'^PROD-\d+$')
    name: str = Field(min_length=1, max_length=100)
    price: PositiveFloat = Field(le=10000)
    in_stock: bool

class ProductFactory(ModelFactory):
    __model__ = Product
```

:::

::: {.column width="50%"}

**Test Data Generation**

```python
# Hypothesis auto-generates valid instances
@given(builds(Product))
def test_product_discount(product):
    discounted = apply_discount(product, 0.1)
    assert discounted.price < product.price
    assert discounted.product_id == product.product_id

# Factory generates test data easily
def test_bulk_operations():
    products = [ProductFactory.build() for _ in range(100)]
    result = bulk_update_inventory(products)
    assert len(result) == 100
```

:::

::::

### TypeScript (Zod + Faker)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";
import { faker } from "@faker-js/faker";

const ProductSchema = z.object({
  productId: z.string().regex(/^PROD-\d+$/),
  name: z.string().min(1).max(100),
  price: z.number().positive().max(10000),
  inStock: z.boolean(),
});

type Product = z.infer<typeof ProductSchema>;
```

:::

::: {.column width="50%"}

**Test Data Generation**

```typescript
// Helper generates valid Product
function generateProduct(): Product {
  return ProductSchema.parse({
    productId: `PROD-${faker.number.int({ min: 1000, max: 9999 })}`,
    name: faker.commerce.productName(),
    price: faker.number.float({ min: 0.01, max: 10000 }),
    inStock: faker.datatype.boolean(),
  });
}

// Use in tests
describe("Product operations", () => {
  it("applies discount correctly", () => {
    const product = generateProduct();
    const discounted = applyDiscount(product, 0.1);
    expect(discounted.price).toBeLessThan(product.price);
  });
});
```

:::

::::

:::

::: {style="background-color: #e3f2fd; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Generate hundreds of valid test cases from your schema!
:::

# Security

*Prevent vulnerabilities through validation*

## Input Sanitization {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *

class UserUpdate(BaseModel):
    model_config = ConfigDict(extra='forbid')
    email: str
```

:::

::: {.column width="50%"}

**Mass Assignment Prevention**

```python
# ‚úÖ Safe request
UserUpdate(email="user@example.com")

# üö´ Malicious fields blocked
UserUpdate(
    email="hacker@evil.com",
    is_admin=True,   # Attack!
    balance=999999,  # Attack!
)
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const UserUpdateSchema = z.strictObject({
  email: z.string().email(),
});
```

:::

::: {.column width="50%"}

**Mass Assignment Prevention**

```typescript
// ‚úÖ Safe request
UserUpdateSchema.parse({ email: "user@example.com" });

// üö´ Malicious fields blocked
UserUpdateSchema.parse({
  email: "hacker@evil.com",
  isAdmin: true,    // Attack!
  balance: 999999,  // Attack!
});
```

:::

::::

:::

::: {style="background-color: #ffebee; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Attackers can't inject fields to escalate privileges!
:::

## Type Confusion Prevention {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *

class PaymentRequest(BaseModel):
    user_id: str
    amount: PositiveFloat
    currency: str = Field(pattern=r'^[A-Z]{3}$')
```

:::

::: {.column width="50%"}

**Type Confusion Prevention**

```python
# ‚úÖ Valid payment
PaymentRequest(
    user_id="USR-123",
    amount=10.0,
    currency="USD"
)

# üö´ String instead of float blocked
PaymentRequest(
    user_id="USR-123",
    amount="0.01 OR 1=1",  # Attack!
    currency="USD"
)

# üö´ Array instead of string blocked
PaymentRequest(
    user_id=["USR-123", "ADMIN"],  # Attack!
    amount=10.0,
    currency="USD"
)
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const PaymentRequestSchema = z.object({
  userId: z.string(),
  amount: z.number().positive(),
  currency: z.string().regex(/^[A-Z]{3}$/),
});
```

:::

::: {.column width="50%"}

**Type Confusion Prevention**

```typescript
// ‚úÖ Valid payment
PaymentRequestSchema.parse({
  userId: "USR-123",
  amount: 10.0,
  currency: "USD",
});

// üö´ String instead of number blocked
PaymentRequestSchema.parse({
  userId: "USR-123",
  amount: "0.01 OR 1=1",  // Attack!
  currency: "USD",
});

// üö´ Array instead of string blocked
PaymentRequestSchema.parse({
  userId: ["USR-123", "ADMIN"],  // Attack!
  amount: 10.0,
  currency: "USD",
});
```

:::

::::

:::

::: {style="background-color: #fff3e0; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Use strict schemas at trust boundaries; coerce only when intentional.
:::

## Size & Range Limits {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *
from typing import Annotated

class CommentSubmission(BaseModel):
    post_id: str
    author: str = Field(min_length=1, max_length=50)
    content: str = Field(min_length=1, max_length=5000)
    tags: list[Annotated[str, Field(max_length=30)]] = Field(max_length=10)
    rating: int = Field(ge=1, le=5)
```

:::

::: {.column width="50%"}

**DoS Attack Prevention**

```python
# üö´ Massive content blocked
CommentSubmission(
    post_id="POST-123",
    author="attacker",
    content="X" * 1_000_000,  # 1MB!
    tags=["spam"] * 1000,     # 1000 tags!
    rating=999                # Out of range!
)
# Errors:
# - content: max 5000 characters
# - tags: max 10 items
# - rating: max 5
```

:::

::::

### TypeScript (Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";

const CommentSubmissionSchema = z.object({
  postId: z.string(),
  author: z.string().min(1).max(50),
  content: z.string().min(1).max(5000),
  tags: z.array(z.string().max(30)).max(10),
  rating: z.number().int().min(1).max(5),
});
```

:::

::: {.column width="50%"}

**DoS Attack Prevention**

```typescript
// üö´ Massive content blocked
CommentSubmissionSchema.parse({
  postId: "POST-123",
  author: "attacker",
  content: "X".repeat(1_000_000),  // 1MB!
  tags: Array(1000).fill("spam"),  // 1000 tags!
  rating: 999,                     // Out of range!
});
// Errors:
// - content: max 5000 character(s)
// - tags: max 10 element(s)
// - rating: max 5
```

:::

::::

:::

::: {style="background-color: #ffebee; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Limit input sizes to prevent memory/storage exhaustion attacks!
:::

# Full-Stack Validation

*Client + Server validation for security and UX*

## Why Both Sides Matter {.smaller}

:::: {.columns}

::: {.column width="50%"}

::: {style="background-color: #ffebee; padding: 15px; border-radius: 10px; font-size: 0.85em;"}

**‚ùå Client-Only Validation**

```typescript
// Frontend validates
const UserSchema = z.object({
  role: z.enum(["user", "guest"]),
});
```

```python
# Backend trusts blindly
@app.post("/api/users")
def create_user(data: dict):
    user = User(**data)  # No validation!
    db.save(user)
```

**Attack:**
```bash
# Bypass frontend entirely
curl -X POST /api/users -d '{
  "role": "admin",
  "balance": 999999
}'
```

**Result**: Privilege escalation and mass assignment risk; injection risk still requires parameterized queries.

:::

:::

::: {.column width="50%"}

::: {style="background-color: #fff3e0; padding: 15px; border-radius: 10px; font-size: 0.85em;"}

**‚ö†Ô∏è Server-Only Validation**

```typescript
// Frontend sends unvalidated data
async function submit(data: any) {
  await fetch("/api/users", {
    method: "POST",
    body: JSON.stringify(data),
  });
}
```

```python
# Backend validates
class User(BaseModel):
    email: EmailStr
    age: int = Field(ge=18)
```

**User Experience:**

1. Submit form ‚Üí wait 200ms
2. "Email invalid" ‚Üí fix ‚Üí wait 200ms
3. "Age too low" ‚Üí fix ‚Üí wait 200ms
4. Finally succeeds after 3 round trips

**Result**: Frustration, poor UX, abandoned forms

:::

:::

::::

::: {style="background-color: #e8f5e9; padding: 20px; border-radius: 10px; margin-top: 15px; text-align: center;"}

Client for UX, server for security. Both are essential. Matching schemas on both sides act as a **contract test** ‚Äì catching API mismatches at runtime.

:::

# Additional Benefits

*More advantages of using validation libraries*

## API Design & Documentation {.smaller}

::: {.panel-tabset}

### Python (FastAPI + Pydantic)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```python
from pydantic import *
from typing import Annotated

UserName = Annotated[str, Field(min_length=3, max_length=20)]

class User(BaseModel):
    model_config = ConfigDict(
        json_schema_extra={
            "example": {
                "user_id": "USR-123",
                "email": "john@example.com",
                "username": "johndoe",
                "is_active": True
            }
        }
    )

    user_id: str = Field(description="Unique user identifier")
    email: EmailStr = Field(description="User's email address")
    username: UserName
    is_active: bool = Field(default=True)
```

:::

::: {.column width="50%"}

**FastAPI Endpoint**

```python
from fastapi import FastAPI

app = FastAPI(title="User API")

@app.post("/users", response_model=User,
          summary="Create new user",
          description="Creates a new user with validated data")
def create_user(user: User) -> User:
    # FastAPI automatically:
    # - Validates request body
    # - Generates OpenAPI/Swagger docs
    # - Provides interactive docs at /docs
    return user

# Visit /docs for auto-generated documentation!
# Schema validation = API docs, always in sync!
```

:::

::::

### TypeScript (Express + Zod)

:::: {.columns}

::: {.column width="50%"}

**Schema Definition**

```typescript
import { z } from "zod";
import { generateSchema } from "@anatine/zod-openapi";

const UserName = z.string().min(3).max(20);

const UserSchema = z.object({
  userId: z.string().describe("Unique user identifier"),
  email: z.string().email().describe("User's email address"),
  username: UserName,
  isActive: z.boolean().default(true),
}).openapi({
  example: {
    userId: "USR-123",
    email: "john@example.com",
    username: "johndoe",
    isActive: true,
  },
});

type User = z.infer<typeof UserSchema>;
```

:::

::: {.column width="50%"}

**Express Endpoint**

```typescript
import express from "express";

const app = express();

app.post("/users", (req, res) => {
  // Validate request body
  const result = UserSchema.safeParse(req.body);

  if (!result.success) {
    return res.status(400).json({ errors: result.error.format() });
  }

  const user: User = result.data;
  // ... create user
  res.json(user);
});

// Generate OpenAPI spec from Zod schemas
const openApiSchema = generateSchema(UserSchema);
// Use with swagger-ui-express for docs
```

:::

::::

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
API docs generated from schemas, always accurate!
:::

## Immutable Configs: Validate Once, Done {.smaller}

::: {.panel-tabset}

### Python (Pydantic)

```python
from pydantic import *

class AppConfig(BaseModel):
    model_config = ConfigDict(frozen=True)

    api_key: str
    max_retries: int = Field(ge=1, le=10)

config = AppConfig(api_key="sk-123", max_retries=3)
config.max_retries = 5  # üö´ ValidationError: frozen instance
```

### TypeScript (Zod)

```typescript
import { z } from "zod";

const AppConfigSchema = z.object({
  apiKey: z.string(),
  maxRetries: z.number().int().min(1).max(10),
}).readonly();

const config = AppConfigSchema.parse({ apiKey: "sk-123", maxRetries: 3 });
config.maxRetries = 5;  // üö´ Compile error: readonly property
```

:::

::: {style="background-color: #e8f5e9; padding: 15px; border-radius: 10px; margin-top: 15px; text-align: center;"}
Validate once at startup, use confidently everywhere without re-checking.
:::

# Summary

*Creating a validated type system that works at runtime*

## Key Takeaways {.smaller}

Data validation libraries like Pydantic and Zod transform how we build applications:

. . .

::: {style="background-color: #e8f5e9; padding: 20px; border-radius: 10px; margin: 15px 0;"}

**Readability**: Self-documenting schemas that serve as single source of truth

**Runtime Safety**: Catch errors at system boundaries before they propagate

**Type Safety**: Bridge the gap between static types and runtime data

**Testing**: Reduce test burden and generate mock data easily

**Security**: Prevent injection, mass assignment, and DoS attacks

:::

. . .

::: {style="background-color: #FFFBC1; padding: 20px; border-radius: 25px; text-align: center; font-size: 1.1em; margin-top: 20px;"}

**Parse, don't pray!** Validate data at boundaries and trust it throughout your application.

:::

# Thank You

And Happy Parsing! üòä

<br>
<br>

::: {style="text-align: center; font-size: 0.7em;"}

Check out my other [slide decks](https://sites.google.com/site/indrajeetspatilmorality/presentations) on software development best practices

:::

::: {style="text-align: center; font-size: 1em;"}

[{{< fa brands linkedin >}}](https://www.linkedin.com/in/indrajeet-patil-ph-d-397865174/)
&nbsp;&nbsp;
[{{< fa brands github >}}](http://github.com/IndrajeetPatil) 
&nbsp;&nbsp;
[{{< fa solid envelope >}}](mailto:patilindrajeet.science@gmail.com)

:::